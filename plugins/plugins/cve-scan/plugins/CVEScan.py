## Minimum required imports
import base64
import codecs
import hashlib
import json
import os
import queue
import re
import sys
import time
import threading
import traceback
import __main__
callLocation = os.path.dirname(os.path.realpath(__main__.__file__))
sys.path.append(os.path.join(callLocation, ".."))

from bson           import json_util
from datetime       import datetime
from libnmap.parser import NmapParser
from uuid           import uuid4
from jinja2         import Environment, FileSystemLoader
from weasyprint     import HTML
from flask          import Flask, render_template

import lib.CVEs          as cves
import lib.DatabaseLayer as db
from lib.Plugins import Plugin, WebPlugin
from lib.Toolkit import toStringFormattedCPE

def toBool(s):
  return s.lower() in ['true', 'yes']

class CVEScan(WebPlugin):
  def __init__(self):
    self.name = "CVE-Scan"
    self.requiresAuth = False
    self.tempPath = "/tmp/CVEScan-pdfs"

    env = Environment(loader=FileSystemLoader(callLocation))
    self.pdf  = env.get_template("templates/plugins/cve-scan_pdf.html")
    self.html = "plugins/cve-scan_webdisplay.html"
    self.collection = "CVEScan"
    self.reaper = Reaper()
    self._set_reaper_status()

  def handle_scan(self, scan, action, tags, notes, store=False):
    try:
      nmap     = self._parseNMap(scan)
      enhanced = self._enhance(nmap)
      if store: self._store_in_db(nmap, tags=tags, notes=notes)
      if   action == "json":
        returndata = json.dumps(enhanced, indent=2, default=json_util.default)
      elif action == "pdf":
        returndata = str(base64.b64encode(self._generatePDF(enhanced)), "utf-8")
      elif action == "webview":
        app = Flask(__name__, template_folder=os.path.join(callLocation, "templates"))
        with app.test_request_context("/"):
          returndata = render_template(self.html, scan=enhanced)
      return returndata
    except Exception as e:
      traceback.print_exc()


  def onCVEAction(self, cve, action, **args):
    if action in ["json", "pdf", "webview"]:
      data  = args["fields"]['scan'][0]
      store = bool(args["fields"]['store'][0])
      tags  = args["fields"]['tags'][0].split(",")
      notes = args["fields"]['notes'][0]
      data = self.handle_scan(data, action, tags, notes, store)
      return {'status': 'plugin_action_complete', 'data': data}
    elif action in ["save_settings"]:
      try:
        data = {"reaper.enable": toBool(args["fields"]["reaper_enable"][0]),
                "reaper.folder":        args["fields"]["reaper_folder"][0],
                "reaper.store":  toBool(args["fields"]["reaper_store"][0]),
                "output.enable": toBool(args["fields"]["output_enable"][0]),
                "output.type":          args["fields"]["output_type"][0],
                "output.folder":        args["fields"]["output_folder"][0] }
        if data["output.type"] not in ["json", "pdf", "webview"]: return False
        if not data["reaper.folder"]: data["reaper.folder"] = "./cve-scan"
        if not data["output.folder"]: data["output.folder"] = "./cve-scan-output"

        for key, val in data.items():
          db.p_writeSetting(self.collection, key, val)

        self._set_reaper_status()
      except Exception as e:
        print(e)
        return False
      return True
    return False


  def getPage(self, **args):
    return ("cve-scan.html", {'plug_id': self.getUID()})

  def getSubpage(self, page, **args):
    if page.lower() == "settings":
      data = {'plug_id': self.getUID(),
              'reaper_enable': self._getSetting("reaper.enable", False),
              'reaper_folder': self._getSetting("reaper.folder", "./cve-scan"),
              'reaper_store':  self._getSetting("reaper.store", True),
              'output_enable': self._getSetting("output.enable", True),
              'output_type':   self._getSetting("output.type", "json"),
              'output_folder': self._getSetting("output.folder", "./cve-scan-output")}
      return ("cve-scan_settings.html", data)

  # CVE Scan code
  def _parseNMap(self, data):
    try:
      report = NmapParser.parse_fromstring(data)
    except Exception as e:
      print(e)
      raise(Exception)
    systems = []
    for h in report.hosts:
      system = {'mac':h.mac, 'ip':h.address, 'status':h.status, 'hostnames': h.hostnames,
                'vendor':h.vendor, 'distance':h.distance}
      cpeList = []
      for c in h.os_match_probabilities():
        cpeList.extend(iter(c.get_cpe()))
      if cpeList := list(set(cpeList)):
        system['cpes']=cpeList
      services = []
      for s in h.services:
        service={'port':s.port, 'banner':s.banner, 'protocol':s.protocol, 'name':s.service,
                 'state':s.state, 'reason':s.reason}
        if s.cpelist:
          service['cpe'] = s.cpelist[0].cpestring
        services.append(service)
      system['services']=services
      systems.append(system)
    return {
        "systems": systems,
        "scan": {
            "time": report.endtime,
            "type": report._nmaprun["args"]
        },
    }

  def _enhance(self, scan):
    cvesp = cves.last(rankinglookup=False, namelookup=False, via4lookup=True, capeclookup=False)
    for system in scan['systems']:
      cpe=system['cpes'] if 'cpes' in system else None

      if cpe:
        cpes=[]
        for c in cpe:
          c=c.lower()
          cpes.append({'cpe':c, 'cves':[cvesp.getcve(x['id'])
                       for x in db.cvesForCPE(toStringFormattedCPE(c))]})
        system['cpes']=cpes
      for service in system['services']:
        if 'cpe' in service:
          service['cves']=db.cvesForCPE(service['cpe'])
    scan['enhanced']={"time": int(datetime.now().strftime('%s'))}
    return scan

  def _generatePDF(self, parsed):
    try:
      filename = os.path.join(self.tempPath, f"{str(uuid4())}.pdf")
      if not os.path.exists(self.tempPath): os.makedirs(self.tempPath)
      self._pdfify(parsed, filename)
      return open(filename, "rb").read()
    except Exception as e:
      print(e)
      raise(PDFGenerationException)

  def _pdfify(self, enhanced, output):
    enhanced["scan"]["time"] = self._fromEpoch(enhanced["scan"]["time"])
    enhanced["enhanced"]["time"] = self._fromEpoch(enhanced["enhanced"]["time"])
    appendixes=[]
    appendix = 1
    for system in enhanced["systems"]:
      if "cpes" in system:
        for cpe in system["cpes"]:
          cpe["cpe"] = self._toHuman(cpe["cpe"])
          if "cves" in cpe and len(cpe["cves"])!=0:
            appendixes.append(cpe["cves"])
            cpe.pop("cves")
            cpe["appendix"]=appendix
            appendix += 1
      for service in system["services"]:
        service["banner"]=self._product(service["banner"])
        if "cves" in service and len(service["cves"])!=0:
          appendixes.append(service["cves"])
          service["appendix"] = appendix
          appendix += 1
        if "cves" in service: service.pop("cves")
    enhanced["appendixes"]=appendixes
    html_out = self.pdf.render(enhanced)
    HTML(string=html_out).write_pdf(output)

  def _fromEpoch(self, epoch):
    return datetime.fromtimestamp(epoch).strftime('%a %d %h %Y at %H:%M:%S')

  def _toHuman(self, cpe):
    cpe = cpe[7:]
    result = cpe.split(':')[0] + " - "
    for c in cpe.split(':')[1:]:
      c = c.replace(':', ' ')
      c = c.replace('_', ' ')
      result += f" {c}"
    result = result.title()
    return result

  def _product(self, banner):
    if banner:
      r=self._make_dict(banner)
      return r['product'] if 'product' in r else 'unknown'
    else:
      return "unknown"

  def _make_dict(self, s):
    chunks = re.split('\s*(\w+\:)\s*',s)
    res={}
    args=[reversed(chunks)]*2
    for value,key in zip(*args):
      key=key.rstrip(':')
      if value:
        res[key]=value
      else:
        res={key:res}
    return res

  def _store_in_db(self, scan, reaper=False, notes=None, tags=None):
    if reaper and not self._getSetting("reaper.store", False):
      return
    # Hash calculation to prevent duplicates
    sha1=codecs.encode(hashlib.sha1(json.dumps(scan).encode('utf-8')).digest(), "hex").decode("utf-8")
    if not db.p_queryData(self.collection, {'sha1': sha1}):
      data={"scan": scan, "sha1": sha1}
      if type(notes) == str: data["notes"] = notes
      if type(tags) == list: data["tags"]  = tags
      db.p_addEntry(self.collection, data)
      return True
    return False

  def _getSetting(self, setting, default):
    s = db.p_readSetting(self.collection, setting)
    if s is None:
      db.p_writeSetting(self.collection, setting, default)
      s = default
    return s


  def _set_reaper_status(self):
    if self._getSetting("reaper.enable", True):
      self.reaper.stop()
      _in = self._getSetting("reaper.folder", "./cve-scan")
      _in = _in if os.path.isabs(_in) else os.path.join(callLocation, '..', _in)
      self.reaper._reap_folder = _in
      self.reaper._on_file     = self.scan_from_file
      self.reaper.start()
    else:
      self.reaper.stop()

  def scan_from_file(self, path):
    try:
      action = self._getSetting("output.type",  "json")
      store  = self._getSetting("reaper.store", False)
      _out   = self._getSetting('output.folder', "./cve-scan-output")
      name   = '.'.join(os.path.basename(path).split('.')[:-1])+'.'+action

      data = self.handle_scan(open(path).read(), action, ['auto'], '', store)
      if self._getSetting("output.enable",  False):
        if action == 'pdf': data = base64.b64decode(data.encode('utf-8'))
        _out = _out if os.path.isabs(_out) else os.path.join(callLocation, '..', _out)

        if type(data) is str: data = data.encode('utf-8')
        try:
          if not os.path.exists(_out): os.path.os.makedirs(_out)
          open(os.path.join(_out, name), 'wb').write(data)
        except Exception as e:
         print("Couldn't write file")
         print(e)
    except Exception as e:
      traceback.print_exc()


class PDFGenerationException(Exception): pass


class Reaper():
  def __init__(self, **kwargs):
    rate   = kwargs.get('rate')
    path   = kwargs.get('path')
    action = kwargs.get('on_file')

    self._refreshrate = rate or 1
    self._reap_folder = path or "."
    self._on_file = action or None

    self.reaping      = False
    self._filequeue   = queue.Queue()
    self._last_state  = []
    self._threads     = []

  def __del__():
    self.stop_reap()

  def start(self):
    self._threads = [threading.Thread(target=self._reap)]
    if self._on_file:
      self._threads.append(threading.Thread(target=self._file_handler))
    for t in self._threads:
      t.daemon = True
      t.start()

  def _reap(self):
    self.reaping = True
    while self.reaping:
      files = self._get_new_files()
      for f in files:
        self._filequeue.put(f)
      time.sleep(self._refreshrate)


  def _file_handler(self):
    while self.reaping:
      f = self._filequeue.get()
      self._on_file(f)

  def stop(self):
    self.reaping = False

  def new_files(self):
    try:
      while not self._filequeue.empty():
        yield self._filequeue.get()
    except:
      return []

  def _get_new_files(self):
    state = self._get_files()
    new = [f for f in state if f not in self._last_state]
    self._last_state = state
    return new

  def _get_files(self):
    try:
      f= [os.path.abspath(os.path.join(self._reap_folder, x))
           for x in os.listdir(self._reap_folder)]
      return [x for x in f if os.path.isfile(x)]
    except:
      return []
